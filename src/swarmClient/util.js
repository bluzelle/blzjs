//
// Copyright (C) 2020 Bluzelle
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const crypto = require('crypto');
const BN = require('bn.js');
const EC = require('elliptic').ec;

const secp256k1 = new EC('secp256k1');

const hash = (hash, data) => crypto.createHash(hash).update(data).digest();

const convertSignature = (sig) => {
  let r = new BN(sig.r);

  if (r.cmp(secp256k1.curve.n) >= 0) {
    r = new BN(0);
  }

  let s = new BN(sig.s);
  if (s.cmp(secp256k1.curve.n) >= 0) {
    s = new BN(0);
  }

  return Buffer.concat([
    r.toArrayLike(Buffer, 'be', 32),
    s.toArrayLike(Buffer, 'be', 32),
  ]);
};

const sortJson = (obj) => {
  if (
    obj === null ||
    ~['undefined', 'string', 'number', 'boolean', 'function'].indexOf(
      typeof obj
    )
  ) {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.sort().map((i) => sortJson(i));
  } else {
    const sortedObj = {};

    Object.keys(obj)
      .sort()
      .forEach((key) => {
        sortedObj[key] = sortJson(obj[key]);
      });

    return sortedObj;
  }
};

module.exports = {
  hash,
  convertSignature,
  sortJson,
};
